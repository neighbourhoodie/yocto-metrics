<!DOCTYPE html>
<html lang="en">
<!--
SPDX-License-Identifier: MIT
-->

<head>
  <meta charset="UTF-8">
  <meta title="Yocto Autobuilder Patch Metrics" <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="resources/echarts.min.js"></script>
  <link rel="stylesheet" href="resources/pico.fluid.classless.min.css">
  <link rel="apple-touch-icon" sizes="144x144" href="/resources/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/resources/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/resources/favicon-16x16.png">
  <style>
    main {
      font-size: 0.9em;
    }

    section {
      max-width: 55rem;
      margin-inline: 3rem;
    }

    h1 {
      padding-inline: 3rem;
    }

    h2 {
      padding-top: 1em;
    }
    details {
      margin-bottom: 0;
    }
    details > ul {
      margin-left: 0;
      padding-left: 14px;
    }
    details > ul > li {
      list-style-type: none;
      font-size: 0.8em;
    }

    details summary::before {
      display: block;
      width: 1rem;
      height: 1rem;
      margin-inline-end: calc(var(--pico-spacing, 1rem)* .5);
      float: left;
      transform: rotate(-90deg);
      background-image: var(--pico-icon-chevron);
      background-position: right center;
      background-size: 1rem auto;
      background-repeat: no-repeat;
      content: "";
      transition: transform var(--pico-transition);
    }

    details summary::after {
      display: inline;
      vertical-align: text-bottom;
      width: auto;
      background: none;
      float: none;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.6em;
      border: 2px solid;
      border-radius: 1em;
      padding-inline: 0.35em;
      content: "Click to show";
    }

    .cve-status>details {
      margin-block-end: 1em;
    }

    .cve-status details summary {
      font-family: var(--pico-font-family-monospace);
    }

    .cve-status details summary:after {
      display: none;
    }

    details[open]>summary {
      margin-bottom: 6px;
    }

    details[open]>summary::before {
      transform: rotate(0);
    }

    details[open]>summary::after {
      transform: none;
      content: "Click to hide";
    }

    details>summary:hover {
      filter: invert(50%);
    }

    summary.sub {
      font-size: 0.8em;
      padding: 6px 18px;
    }
  </style>
</head>

<body>
  <main>
    <h1>yocto-metrics</h1>
    <section>
      <p>This page shows Common Vulnerabilities and Exposures (CVEs) metrics gathered from the Yocto Project autobuilder in graphs. It is updated daily to show the current status of the project.</p>
      <p>
        Each graph (except the pie chart) has an <strong>x-axis</strong> and a <strong>y-axis:</strong>
      </p>
      <ul>
        <li>The <strong>x-axis</strong> represents time. You can filter by time-range using the zoom bar at the bottom.</li>
        <li>The <strong>y-axis</strong> represents the amount of something (CVEs, patches, errors etc.) at a particular point in time. You can zoom here as well, using the bar on the right.</li>
      </ul>
      <p>
        Click on the items in the <strong>legend</strong> to toggle the visibility of the corresponding line on the graph.</p>
      <p>
        Note the grey, vertical lines representing <strong>releases</strong>.
        These lines are not part of the graphâ€™s data but are added to highlight release points in time. They denote the release of new versions or updates of the software. This helps you correlate vulnerability trends with software releases, which can indicate whether vulnerabilities were addressed in a particular release.
      </p>
    </section>

    <section>
      <h2>Current CVE status for OE-Core/Poky</h2>
      <p>
        This section provides a detailed overview of the current status of CVEs for each branch in the <code>OE-Core/Poky</code> repository.</p>
      <p>
        When you click on a branch name, a summary count of CVEs related to that branch is displayed.
        This count includes the total number of CVEs reported for that branch and so gives a quick overview of the security status of the branch.</p>
      <p>
        Below the summary count, you'll find links to more detailed information about CVEs for that branch. You can easily access more detailed information at the National Vulnerability Database (NVD), about CVEs for each branch by clicking on the provided links.</p>
      <div class="cve-status">
        <details>
          <summary>master</summary>
          <div id="cve_status_master"></div>
        </details>
        <details>
          <summary>scarthgap</summary>
          <div id="cve_status_scarthgap"></div>
        </details>
        <details>
          <summary>nanbield</summary>
          <div id="cve_status_nanbield"></div>
        </details>
        <details>
          <summary>kirkstone</summary>
          <div id="cve_status_kirkstone"></div>
        </details>
        <details>
          <summary>dunfell</summary>
          <div id="cve_status_dunfell"></div>
        </details>
      </div>
    </section>

    <section>
      <h2>CVE Trends for <code>OE-Core/Poky</code></h2>
      <p>
        This graph shows the trends of CVEs affecting the <code>OE-Core/Poky</code> repository over time.</p>
      <p>
        It shows how many vulnerabilities have been identified within the <code>OE-Core/Poky</code> repository, per branch.
        The colored lines show the trend of CVEs for each branch, allowing you to see how vulnerabilities evolve over time.
      </p>
    </section>

    <div id='cve_chart' style='height:400px;'></div>

    <section>
      <h3>Current Patch Status Pie</h3>
      <div id='pie_chart' style='height:300px; width: 600px;'></div>
    </section>

    <section>
      <h3>Patch Upstream-Status Counts (OE-Core meta directory)</h3>
      <div id="upstream_status_chart" style="height:400px;"></div>
    </section>

    <section>
      <h3>Patch Tag Error Counts (OE-Core meta directory)</h3>
      <div id="malformed_chart" style="height:400px;"></div>
    </section>

    <section>
      <h3>Recipe Count (OE-Core meta directory)</h3>
      <div id="recipe_chart" style="height:400px;"></div>
    </section>

    <h3>Raw Data</h3>
    <ul>
      <li><a href="patch-status-pie.json">patch-status-pie.json</a></li>
      <li><a href="patch-status-byday.json">patch-status-byday.json</a></li>
      <li><a href="cve-count-byday.json">cve-count-byday.json</a></li>
      <li><a href="releases.csv">releases.csv</a></li>
    </ul>
  </main>

  <script type="text/javascript">
    fetch('cve-status-master.txt')
   .then(response => response.text())
   .then(data => {
      createCVEList('cve_status_master', data);
   })

   fetch('cve-status-scarthgap.txt')
   .then(response => response.text())
   .then(data => {
       createCVEList('cve_status_scarthgap', data);
   })

   fetch('cve-status-nanbield.txt')
   .then(response => response.text())
   .then(data => {
       createCVEList('cve_status_nanbield', data);
   })

   fetch('cve-status-kirkstone.txt')
   .then(response => response.text())
   .then(data => {
       createCVEList('cve_status_kirkstone', data);
   })

   fetch('cve-status-dunfell.txt')
   .then(response => response.text())
   .then(data => {
       createCVEList('cve_status_dunfell', data);
   })

    function parseTxtFile(data) {
      const cveData = {}
      const txtCVEs = data.split(/\n\s*\n/)
      // skip the header
      for (let i = 1; i < txtCVEs.length; i++) {
        const urls = txtCVEs[i].split("\n");
        packageName = urls[0]

        cveData[packageName] = []
        for (let i = 1; i < urls.length; i++) {
          cveData[packageName].push(urls[i].toString().trim());
        }
      }
      return cveData
    }

    function createCVEList(listid, data) {
      const nestedDetails = document.getElementById(listid);
      const cveData = parseTxtFile(data)
      let html = "";
      for (let [name, cves] of Object.entries(cveData)) {
        html += '<details>';
        html += `<summary class="sub">${name} CVEs</summary>`;
        html += "<ul>";
        for (const cve of cves) {
          html += '<li>'
          html += `<a href="${cve}" target="_blank">${cve}</a>`
          html += '</li>';
        }
        html += "</ul>";
        html += "</details>";
        nestedDetails.innerHTML = html;
    };
   }
  </script>

  <!-- get the data -->
  <script type="text/javascript">
    const status_names = {
      pending: 'Pending',
      backport: 'Backport',
      inappropriate: 'Inappropriate',
      accepted: 'Accepted',
      submitted: 'Submitted',
      denied: 'Denied',
      total: 'Total',
      sob: 'Malformed Signed-off-by',
      upstream_status: 'Malformed Upstream-Status'
    };
    const branches = ['master', 'scarthgap', 'nanbield', 'mickledore', 'langdale', 'kirkstone', 'honister', 'hardknott', 'gatesgarth', 'dunfell']

    const general_options = {
      tooltip: {
        order: 'valueDesc',
        trigger: 'axis'
      },
      legend: {},
      xAxis : { type: 'time' },
      yAxis: { type: 'value' },
      dataZoom: [
        {
          type: 'slider',
          xAxisIndex: 0,
          filterMode: 'none'
        },
        {
          type: 'slider',
          yAxisIndex: 0,
          filterMode: 'none'
        }
      ]
    }

    fetch('releases.csv')
      .then(response => response.text())
      .then(data => {
        const release_lines = []
        const lines = data.split("\n")
        // skip the header
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].split(",");
          if(line.length) {
            const cve = {
              name: line[0],
              xAxis: new Date(line[1])
            }
            release_lines.push(cve)
          }
        }
        const releases = {
          type: 'line',
          datasetId: 'releases',
          markLine: {
            lineStyle: { color: '#aaa' },
            symbol: ['none', 'none'],
            label: {
              formatter: '{b}',
              color: '#777'
            },
            data: release_lines
          },
        }
        return releases
      }).then((releases) => {
        fetch('cve-count-byday.json')
          .then(response => response.json())
          .then(data => {
            const cve_data = []
            cve_data.push(['Date', 'Branch', 'Branchvalue']);
            for (var key in data) {
              const dateObj = new Date(key * 1000);
              for (let branchVal in data[key]) {
                let entry = [dateObj, branchVal, parseInt(data[key][branchVal])]
                cve_data.push(entry)
              }
            }
            generateCVEChart({ cve_data, releases });
            return releases;
          }).then((releases) => {
        fetch('patch-status-byday.json')
          .then(response => response.json())
          .then(data => {
            // We have to sort the data by date
            data.sort(function(x, y){
              return x.date - y.date;
            })

            const patch_data = data.map(status => {
              return {
                date: new Date(status.date * 1000),
                total: status.total,
                pending: status.pending || 0,
                backport: status.backport || 0,
                inappropriate: status.inappropriate || 0,
                accepted: status.accepted || 0,
                submitted: status.submitted || 0,
                denied: status.denied || 0
              }
            })

            const malformed_data = data.map(status => {
              return {
                date: new Date(status.date * 1000),
                total: status.total,
                upstream_status: status['malformed-upstream-status'] || 0,
                sob: status['malformed-sob'] || 0
              }
            })

            const recipe_data = data.map(status => {
              return {
                date: new Date(status.date * 1000),
                recipe_count: status.recipe_count
              }
            })

            generateMalformedChart({ malformed_data, releases });
            generateUpstreamChart({ patch_data, releases });
            generateRecipeChart({ recipe_data, releases });
          });
        });
      });
  </script>

  <!-- cve_chart -->
  <script type="text/javascript">
  if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
    // dark mode
    var cveChart = echarts.init(document.getElementById('cve_chart'), 'dark');
  } else {
    var cveChart = echarts.init(document.getElementById('cve_chart'));
  }

  const cveSeries = []
  const datasetWithFilters = []
  function generateCVEChart({ cve_data, releases }) {
    branches.forEach(branch => {
      datasetWithFilters.push({
        id: branch,
        fromDatasetId: 'dataset_raw',
        transform: {
          type: 'filter',
          config: {
            dimension: 'Branch', '=': branch,
          }
        }
      });
      cveSeries.push({
        type: 'line',
        showSymbol: false,
        datasetId: branch,
        name: branch,
        encode: {
          x: 'Date',
          y: 'Branchvalue'
        }
      });
    });
    const cveOption = {
      legend: { right: 'auto' },
      ...general_options,
      dataset: [
        {
          id: 'dataset_raw',
          source: cve_data
        },
        ...datasetWithFilters
      ],
      series: [
        releases,
        ...cveSeries,
      ]
    };

    cveChart.setOption(cveOption);
  }
  </script>

  <!-- pie chart -->
  <script>
    // dark mode
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      var pieChart = echarts.init(document.getElementById('pie_chart'), 'dark');
    } else {
      var pieChart = echarts.init(document.getElementById('pie_chart'));
    }

    fetch('patch-status-pie.json')
      .then(response => response.json())
      .then(data => {
        const formatted = [
          { "value": data.pending || 0, "name": "Pending" },
          { "value": data.backport || 0, "name": "Backport" },
          { "value": data.inappropriate || 0, "name": "Inappropriate" },
          { "value": data.accepted || 0, "name": "Accepted" },
          { "value": data.submitted || 0, "name": "Submitted" },
          { "value": data.denied || 0, "name": "Denied" }
        ]
        generatePieChart(formatted)
      });

    function generatePieChart(data) {
      const pieOption = {
        tooltip: { trigger: 'item' },
        series: [{
          type: 'pie',
          radius: '50%',
          data: data,
          label: { formatter: '{b} {d}%' },
        }],
        emphasis: {
          itemStyle: {
            shadowBlur: 10,
            shadowOffsetX: 0,
            shadowColor: 'rgba(0, 0, 0, 0.5)'
          }
        }
      };
      pieChart.setOption(pieOption);
    }
  </script>

  <!-- patch status -->
  <script type="text/javascript">
    // dark mode
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      var upstreamStatusChart = echarts.init(document.getElementById('upstream_status_chart'), 'dark');
    } else {
      var upstreamStatusChart = echarts.init(document.getElementById('upstream_status_chart'));
    }

    function generateUpstreamChart({ patch_data, releases }) {
      releases.markLine.label.position = 'insideEndTop';
      const keys = Object.keys(patch_data[0]);
      const upstreamSeries = keys
        .filter(status => status !== 'date')
        .map(status => ({
          type: 'line',
          showSymbol: false,
          areaStyle: {},
          name: status_names[status],
          encode: { x: 'Date', y: status }
        }));

      const upstreamOption = {
        ...general_options,
        dataset: { source: patch_data },
        series: [
          releases,
          ...upstreamSeries
        ]
      };

      upstreamStatusChart.setOption(upstreamOption);
    }
  </script>

  <!-- malformed upstream -->
  <script type="text/javascript">
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      var malformedChart = echarts.init(document.getElementById('malformed_chart'), 'dark');
    } else {
      var malformedChart = echarts.init(document.getElementById('malformed_chart'));
    }

    function generateMalformedChart({ malformed_data, releases }) {
      releases.markLine.label.position = 'insideEndTop';
      const keys = Object.keys(malformed_data[0]);
      const malformedSeries = keys
        .filter(status => status !== 'date')
        .map(status => ({
          type: 'line',
          showSymbol: false,
          areaStyle: {},
          name: status_names[status],
          encode: { x: 'Date', y: status }
        }));

      const malformedOption = {
        ...general_options,
        legend: {},
        dataset: { source: malformed_data },
        series: [
          releases,
          ...malformedSeries
        ]
      };

      malformedChart.setOption(malformedOption);
    }
  </script>

  <!-- recipe count -->
  <script type="text/javascript">
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      var recipeChart = echarts.init(document.getElementById('recipe_chart'), 'dark');
    } else {
      var recipeChart = echarts.init(document.getElementById('recipe_chart'));
    }

    function generateRecipeChart({ recipe_data, releases }) {
      releases.markLine.label.position = 'insideEndTop';

      const recipeOption = {
        ...general_options,
        dataset: { source: recipe_data },
        series: [
          releases,
          {
            type: 'line',
            showSymbol: false,
            name: 'Recipe Count',
            areaStyle: {},
          }
        ]
      };

      recipeChart.setOption(recipeOption);
    }
  </script>
</body>

</html>